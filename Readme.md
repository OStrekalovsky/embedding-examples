# Положительные стороны
Встраивание позволяет уменьшить количество шаблонного кода, который занимается делегированием.

## Частичная реализация интерфейса
Встраивание интерфейса в структуру приводит к тому, что структура начинает реализовывать интерфейс, даже если поле с интерфейсом не было инициализировано.
Можно переопределить необходимый минимум методов интерфейса и использовать такую структуру.
Это позволяет минимальными усилиями создавать моки для интерфейсов с большим количеством методов без кодогенерации.

### Пример
partial_interface_impl

## Встраивание структуры, реализующий интерфейс, делает внешнюю структуру также реализующей этот интерфейс
Можно создать разные типы ошибок, каждая из которых будет по-своему обрабатываться через единый API, без необходимости добавления методов.

### Пример
interface_embedding_into_errors

## Встраивание позволяет создавать переиспользуемые системы обобщенных компонентов (aka паттерны), которыми можно легко обогатить структуры.

### Пример
observer

# Отрицательные стороны

## Невозможность вызова переопределённого метода из запромоученного

### Пример 
inside_out/octo_cat_test.go

### Решение
Паттерн "Client-Specified Self" (пример inside_out/template_method_test): 
  1. Создание интерфейса для внутреннего типа
  2. Для всех методов внутреннего типа, которые должны уметь вызывать переопределённые версии других методов, добавляется параметр с типом созданного интерфейса и
и методы вызываются на переменной интерфейса, а не на ресивере.

## Встраивание публичных типов становится частью публичного API
Потенциальная утечка деталей реализации в потребителя

### Пример 
leaked_details/counter_usage_test.go

### Решение 
- Отказ от встраивания того, что не должно быть доступно.
- Если возможно - сделать встраиваемый тип приватным.

## Структуру со встроенным типом нельзя передать в метод, который ожидает встроенный тип.
Встраивание не создаёт связь "внешний тип является внутренним типом".

### Пример
common_dna

### Решение
Для унификации обработки разных типов нужно использовать интерфейсы.

## Обработка nil ресиверов для встроенного типа не спасает от паник внешнего типа

### Пример
nil_receiver

### Решение
- Создание конструкторов внешнего типа, которые обеспечивают инициализацию всех встроенных указателей.
- Переопределение методов встроенного типа с дополнительной проверкой на nil для указателя.