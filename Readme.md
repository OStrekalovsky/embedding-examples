В этом репозитории намеренно опущены примеры очевидного использования встраивания, которые описаны в большинстве обучающих материалов:
- композиция интерфейсов
- добавление полей структурам
- обработка встроенных структур сериализатором JSON

Внимание уделено менее очевидным примерам, которые подчеркивают важные положительные и негативные свойства встраивания в Go.

# Положительные стороны
Встраивание позволяет уменьшить количество шаблонного кода, который занимается делегированием, или должен быть написан, чтобы структура реализовала нужный интерфейс.


## Частичная реализация интерфейса
Встраивание интерфейса в структуру приводит к тому, что структура начинает реализовывать интерфейс, даже если поле с интерфейсом не было инициализировано.
Можно переопределить необходимый минимум методов интерфейса и использовать такую структуру.
Это позволяет минимальными усилиями создавать моки для интерфейсов с большим количеством методов без кодогенерации.

### Пример
partial_interface_impl

## Встраивание структуры, реализующий интерфейс, делает внешнюю структуру также реализующей этот интерфейс
Можно создать разные типы ошибок, каждая из которых будет по-своему обрабатываться через единый API, без необходимости добавления методов.

### Пример
interface_embedding_into_errors

## Встраивание позволяет создавать переиспользуемые системы обобщенных компонентов (aka паттерны), которыми можно легко обогатить структуры.

### Пример
observer

# Отрицательные стороны

## Невозможность вызова переопределённого метода из запромоученного

### Пример 
inside_out/octo_cat_test.go

### Решение
Паттерн "Client-Specified Self" (пример inside_out/octo_cat_fixed_test.go): 
  1. Создание интерфейса для внутреннего типа
  2. Для всех методов внутреннего типа, которые должны уметь вызывать переопределённые версии других методов, добавляется параметр с типом созданного интерфейса,
и методы вызываются на переменной интерфейса, а не на ресивере.

## Встраивание публичных типов становится частью публичного API
Потенциальная утечка деталей реализации в потребителя. В том числе публичные методы встроенных приватных типов.

### Пример 
leaked_details/counter_usage_test.go

### Решение 
- Отказ от встраивания того, что не должно быть доступно.
- Если возможно - сделать встраиваемый тип и все его методы приватными.

## Структуру со встроенным типом нельзя передать в метод, который ожидает встроенный тип.
Встраивание не создаёт связь "внешний тип является внутренним типом".

### Пример
common_dna

### Решение
Для унификации обработки разных типов нужно использовать интерфейсы.

## Паники при вызове методов на nil ресивере внешнего типа
Известно, что можно вызывать методы на nil ресивере. 
Но если вызываемый метод является запромоушенным из встроенного типа, то попытка его вызвать на внешнем nil ресивере приведёт к панике.

### Пример
nil_receiver

### Почему так происходит
Т.к. метод `Empty()` не переопределён у `RenderedCart`, то вызов `cfg.c.Empty()` трансформируется в `cfg.c.Cart.Empty()`.
И попытка чтения поля `Cart` у nil указателя `cfg.c` приводит к панике.


### Решение
- Переопределение методов встроенного типа с дополнительной проверкой на nil для указателя внешнего типа.